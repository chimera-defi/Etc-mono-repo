# Cursor Rules for Mobile Experiments Repository

## Project Structure
- All AI-generated artifacts and temporary files should be placed in `.cursor/artifacts/`
- Keep experimental projects organized in their respective folders (e.g., `mobile_experiments/Valdi/`)
- Maintain clean separation between source code and generated content

## Code Organization
- Follow platform-specific conventions (iOS/Swift, React Native, etc.)
- Keep experimental code well-documented with clear comments
- Use consistent naming conventions within each project

## File Management
- Never litter the root directory with generated files
- Place all temporary or generated artifacts in `.cursor/artifacts/`
- Keep README files updated with project status and setup instructions

## AI Assistant Guidelines
- When generating code, prefer creating new files over modifying existing ones unless explicitly requested
- Always check for existing similar implementations before creating new ones
- Document assumptions and limitations in code comments
- When unsure about framework specifics, create a flexible structure that can be adapted

## Valdi Framework Notes
- Valdi is Snapchat's cross-platform framework (iOS, Android, macOS) - NOT iOS-only
- Uses TypeScript/TSX with class-based components, lowercase tags (`<view>`, `<label>`), `onRender()` method
- Project structure requirements: `modules/my_app/src/` structure with `platforms/` folders and `WORKSPACE` file
- Import path: `valdi_core/src/Component` (verify against actual installation)
- CLI: `npm install -g @snap/valdi`, then `valdi dev_setup`, `valdi bootstrap`, `valdi install ios/android/macos`
- Official repo: https://github.com/Snapchat/Valdi (13k+ stars, active development)
- Always verify project structure matches Valdi requirements before proceeding

## Meta Learnings
- When working with new/experimental frameworks:
  1. Start with minimal viable structure
  2. Document assumptions clearly
  3. Create flexible boilerplates that can adapt
  4. Keep experimental code separate from production-ready code
  5. Always include setup instructions and next steps in README
  6. When documentation is unavailable, create comprehensive handoff documents:
     - Task lists with clear priorities
     - Understanding documents explaining research strategy
     - Documentation placeholders for discovered information
     - Next steps documents with actionable items
  7. For agent handoffs, create:
     - HANDOFF.md with quick start guide
     - TASKS.md with detailed task breakdown
     - UNDERSTANDING.md with context and research strategy
     - NEXT_STEPS.md with prioritized action items
  8. Document search attempts and results, even if unsuccessful
  9. Clearly mark placeholder code vs. actual framework code
  10. Set realistic expectations about framework availability

- Review and verification best practices:
  11. **Always verify project structure** against framework requirements - don't assume structure is correct just because code syntax looks right
  12. **Cross-reference documentation** - check for inconsistencies between different docs, and verify docs match actual project state
  13. **Verify import paths** - don't trust import statements without verifying they match actual framework installation
  14. **Conceptual execution** - mentally walk through setup/run steps to identify blockers before they're discovered
  15. **Multi-path analysis** - consider perspectives: developer (can I use this?), PM (risks?), reviewer (correctness?), user (does it work?), maintainer (maintainability?)
  16. **Structural verification checklist** - always verify: project structure matches requirements, import paths are correct, all components are used, required files exist
  17. **Dead code detection** - check if all code is actually used; unused code creates confusion
  18. **Documentation consistency** - check for outdated references, contradictory info, missing updates across all docs
  19. **Never trust without verification** - verify claims against actual framework requirements, even if documentation says it's correct
  20. **Think about runability** - code that looks correct but can't run is worse than no code

## Best Practices
- Use semantic versioning for packages
- Include proper .gitignore files for each project type
- Maintain clear separation between different experiments
- Document tooling requirements and setup steps
- Keep dependencies minimal for experimental projects
